var Ajaxpect = {
    addBefore: function (t, e, n) {
        var r = function (t) {
            return function () {
                return t.apply(this, n(arguments, t, this))
            }
        };
        this._process(t, e, r)
    }, addAfter: function (t, e, n) {
        var r = function (t) {
            return function () {
                return n(t.apply(this, arguments), arguments, t, this)
            }
        };
        this._process(t, e, r)
    }, addAround: function (t, e, n) {
        var r = function (t) {
            return function () {
                return n(arguments, t, this)
            }
        };
        this._process(t, e, r)
    }, _process: function (t, e, n) {
        var r;
        if (e.exec ? r = function (t) {
                return e.exec(t)
            } : e.call && (r = function (t) {
                return e.call(this, t)
            }), r)for (var o in t)r(o) && this._attach(t, o, n); else this._attach(t, e, n)
    }, _attach: function (t, e, n) {
        var r = t[e];
        t[e] = n(r)
    }
}, inheritanceUtil = {
    object: function (t) {
        var e = function () {
        };
        return e.prototype = t, new e
    }, inheritPrototype: function (t, e) {
        var n = this.object(e.prototype);
        n.constructor = t, t.prototype = n
    }, inheritPrototypeAndAugment: function (t, e, n) {
        this.inheritPrototype(t, e);
        for (var r in n)n.hasOwnProperty(r) && (t.prototype[r] = n[r])
    }, superConstructor: function (t, e, n) {
        e.apply(t, n)
    }, isAbstract: function (t) {
        if (t.caller !== this.superConstructor)throw new Error("Inheritance error: The constructor" + t + " is an abstract constructor and can only be used as superConstructor()")
    }
}, reconstructorExceptions = function () {
    var t = function (e) {
        inheritanceUtil.isAbstract(t), inheritanceUtil.superConstructor(this, Error, arguments), this.message = e
    }, e = {constructor: t, name: "ReconstructionException"};
    inheritanceUtil.inheritPrototypeAndAugment(t, Error, e);
    var n = function (e) {
        inheritanceUtil.superConstructor(this, t, [e])
    }, r = {constructor: n, name: "InvalidArgumentException"};
    inheritanceUtil.inheritPrototypeAndAugment(n, t, r);
    var o = function (e) {
        inheritanceUtil.superConstructor(this, t, [e])
    }, s = {constructor: o, name: "ReferenceException"};
    inheritanceUtil.inheritPrototypeAndAugment(o, t, s);
    var c = function (e) {
        inheritanceUtil.superConstructor(this, t, [e])
    }, i = {constructor: c, name: "InvalidReconstructionException"};
    inheritanceUtil.inheritPrototypeAndAugment(c, t, i);
    var a = function (e) {
        inheritanceUtil.superConstructor(this, t, [e])
    }, u = {constructor: a, name: "NoSuchPropertyException"};
    inheritanceUtil.inheritPrototypeAndAugment(a, t, u);
    var h = function (e) {
        inheritanceUtil.superConstructor(this, t, [e])
    }, l = {constructor: h, name: "NoSuchMethodException"};
    return inheritanceUtil.inheritPrototypeAndAugment(h, t, l), {
        ReconstructionException: t,
        InvalidArgumentException: n,
        ReferenceException: o,
        InvalidReconstructionException: c,
        NoSuchPropertyException: a,
        NoSuchMethodException: h
    }
}(), check = {
    isArray: function (t) {
        if (!(t instanceof Array))throw new reconstructorExceptions.InvalidArgumentException("isArray(" + t + ") Error: Argument must be an Array")
    }, isString: function (t) {
        if (!("string" == typeof t || t instanceof String))throw new reconstructorExceptions.InvalidArgumentException("isString(" + t + ") Error: Argument must be a String")
    }, isNumber: function (t) {
        if (!("number" == typeof t || t instanceof Number))throw new reconstructorExceptions.InvalidArgumentException("isNumber(" + t + ") Error: Argument must be a Number")
    }, isNotUndefined: function (t) {
        if (!t)throw new reconstructorExceptions.ReferenceException("isNotUndefined(" + t + ") Error: Argument must not be undefined")
    }, isFunction: function (t) {
        if ("function" != typeof t)throw new reconstructorExceptions.InvalidArgumentException("isFunction(" + t + ") Error: Argument must be a function, and it's a " + typeof t)
    }, objectPropertyExists: function (t, e) {
        if (void 0 === t[e])throw new reconstructorExceptions.NoSuchPropertyException("objectHasOwnProperty(" + t + ", " + e + ") Error: " + t + "[" + e + "] doesn't exist")
    }, objectPropertyIsMethod: function (t, e) {
        if (void 0 === t[e])throw new reconstructorExceptions.NoSuchMethodException("objectPropertyIsMethod(" + t + ", " + e + ") Error: " + t + "[" + e + "] doesn't exist");
        if ("function" != typeof t[e])throw new reconstructorExceptions.NoSuchMethodException("objectPropertyIsMethod(" + t + ", " + e + ") Error: " + t + "[" + e + "] exists but it must be a Function, and it's type is " + typeof t[e])
    }, isContext: function (t) {
        if (!(t instanceof BaseContext))throw new reconstructorExceptions.InvalidArgumentException("isContext(" + t + ") Error: Argument must be a Context instance")
    }, isReconstructor: function (t) {
        if (!(t instanceof Reconstructor))throw new reconstructorExceptions.InvalidArgumentException("isReconstructor(" + t + ") Error: Argument must be an ImplicitReconstructor or ExplicitReconstructor reconstructor instance")
    }, isReconstructionOptions: function (t) {
        if (!(t instanceof ReconstructionOptions))throw new reconstructorExceptions.InvalidArgumentException("isReconstructionOptions(" + t + ") Error: Argument must be a ReconstructionOptions instance")
    }, isRetry: function (t) {
        if (!(t instanceof Retry))throw new reconstructorExceptions.InvalidArgumentException("isRetry(" + t + ") Error: Argument must be a Retry instance")
    }
}, lastAsyncElementId = 0, AsyncElements = function () {
    this._map = new Map
};
AsyncElements.prototype = function () {
    var t = 0, e = 1, n = 2, r = 3;
    return {
        constructor: AsyncElements, addNewAsyncElement: function (t) {
            return lastAsyncElementId++, this._map.set(lastAsyncElementId, t), lastAsyncElementId
        }, addNewAjaxAsyncElement: function (e) {
            this.addNewAsyncElement({type: t, value: e})
        }, addNewTimeoutAsyncElement: function (t) {
            this.addNewAsyncElement({type: e, value: t})
        }, addNewTimeintervalAsyncElement: function (t) {
            this.addNewAsyncElement({type: n, value: t})
        }, addNewMutationObserverAsyncElement: function (t, e, n) {
            this.addNewAsyncElement({type: r, value: t, node: e, options: n})
        }, hasAsyncElementId: function (t) {
            this._map.has(t)
        }, deleteAsyncElementById: function (t) {
            this._map["delete"](t)
        }, getAsyncElements: function () {
            return this._map
        }, areThereAsyncElements: function () {
            return this._map.size > 0 ? !0 : !1
        }
    }
}();
var reconstructableDomElements = {
    mapOfIds: new Map, mapOfClasses: new Map, getElementId: function (t) {
        var e = t.id;
        return 0 !== e.length ? e : (e = t.tagName + t.classList[0] + t.innerHTML, t.id = e, e)
    }, addElementToIdMap: function (t) {
        this.mapOfIds.set(this.getElementId(t), t)
    }, addIdProperties: function (t, e) {
        var n = this.mapOfIds.get(t);
        "undefined" == typeof n ? (n = reconstructable.object.domElement(document.originalGetElementById(t), e), this.mapOfIds.set(t, n)) : e.forEach(function (t) {
            n._reconstructableElements.addProperty(t)
        })
    }, addClassProperties: function (t, e) {
        var n = this.mapOfClasses.get(t);
        if ("undefined" == typeof n) {
            n = [];
            var r = document.originalGetElementsByClassName(t);
            Array.prototype.forEach.call(r, function (t) {
                n.push(reconstructableDomElements.getElementId(t))
            })
        }
        n.forEach(function (t) {
            reconstructableDomElements.addIdProperties(t, e)
        }), this.mapOfClasses.set(t, n)
    }, getReconstructableElementById: function (t) {
        return this.mapOfIds.get(t)
    }, getReconstructableElementsByClassName: function (t) {
        var e = this.mapOfClasses.get(t);
        if ("undefined" == typeof e)return e;
        var n = [];
        return e.forEach(function (t) {
            n.push(reconstructableDomElements.getReconstructableElementById(t))
        }), n
    }, getIdProperties: function (t) {
        var e = this.mapOfIds.get(t);
        return "undefined" == typeof e ? [] : Array.from(e)
    }, getClassProperties: function (t) {
        var e = this.mapOfClasses.get(t);
        return "undefined" == typeof e ? [] : Array.from(e)
    }, idPropertyExists: function (t, e) {
        return this.mapOfIds.get(t).has(e)
    }, classPropertyExists: function (t, e) {
        return this.mapOfClasses.get(t).has(e)
    }
}, ReconstructableArray = function (t) {
    this._array = t;
    for (var e = t.length, n = 0; e > n; n++) {
        var r = new Function("return this._array[" + n + "];"), o = new Function("value", "if (ContextFactory.hasActiveContext()){                ContextFactory.getCurrentContext().addReconstructor(new ImplicitReconstructor(this._array, " + n + "));			}			this._array[" + n + "] = value;");
        Object.defineProperty(this, n, {get: r, set: o, configurable: !0, enumerable: !0})
    }
    Object.defineProperty(this, "length", {
        get: function () {
            return this._array.length
        }, configurable: !0, enumerable: !0
    })
}, funSetCodeArray = function (t, e) {
    ContextFactory.hasActiveContext() && ContextFactory.getCurrentContext().addReconstructor(new ImplicitReconstructor(this._array, e)), this._array[e] = t
};
ReconstructableArray.prototype = {
    constructor: ReconstructableArray, reverse: function () {
        this._array.reverse()
    }, shift: function () {
        return this._array.shift()
    }, pop: function () {
        return this._array.pop()
    }, addNewElementInPosition: function (t, e) {
        if (this._array.hasOwnProperty(t))return void(this[t] = e);
        ContextFactory.hasActiveContext() && (ContextFactory.getCurrentContext().addReconstructor(new ExplicitReconstructor(this, "compensateAddNewElementInPosition", [t, e])), ContextFactory.getCurrentContext().reconstructableMethodEntry()), this._array[t] = e;
        var n = new Function("return this._array[" + t + "];"), r = new Function("value", "if (ContextFactory.hasActiveContext()){                ContextFactory.getCurrentContext().addReconstructor(new ImplicitReconstructor(this._array, " + t + "));			}			this._array[" + t + "] = value;");
        Object.defineProperty(this, t, {
            get: n,
            set: r,
            configurable: !0,
            enumerable: !0
        }), ContextFactory.hasActiveContext() && ContextFactory.getCurrentContext().reconstructableMethodExit()
    }, compensateAddNewElementInPosition: function (t) {
        delete this._array[t], delete this[t], this._array.length--
    }, push: function (t) {
        var e = this._array.length;
        ContextFactory.hasActiveContext() && (ContextFactory.getCurrentContext().addReconstructor(new ExplicitReconstructor(this, "compensateAddNewElementInPosition", [e, t])), ContextFactory.getCurrentContext().reconstructableMethodEntry()), this._array.push(t);
        var n = new Function("return this._array[" + e + "];"), r = new Function("value", "if (ContextFactory.hasActiveContext()){                ContextFactory.getCurrentContext().addReconstructor(new ImplicitReconstructor(this._array, " + e + "));			}			this._array[" + e + "] = value;");
        return Object.defineProperty(this, e, {
            get: n,
            set: r,
            configurable: !0,
            enumerable: !0
        }), ContextFactory.hasActiveContext() && ContextFactory.getCurrentContext().reconstructableMethodExit(), this._array.length
    }, unshift: function (t) {
        var e = this._array.length;
        ContextFactory.hasActiveContext() && (ContextFactory.getCurrentContext().addReconstructor(new ExplicitReconstructor(this, "compensateUnshift", [t])), ContextFactory.getCurrentContext().reconstructableMethodEntry()), this._array.unshift(t);
        var n = new Function("return this._array[" + e + "];"), r = new Function("value", "if (ContextFactory.hasActiveContext()){                ContextFactory.getCurrentContext().addReconstructor(new ImplicitReconstructor(this._array, " + e + "));			}			this._array[" + e + "] = value;");
        return Object.defineProperty(this, e, {
            get: n,
            set: r,
            configurable: !0,
            enumerable: !0
        }), ContextFactory.hasActiveContext() && ContextFactory.getCurrentContext().reconstructableMethodExit(), this._array.length
    }, compensateUnshift: function () {
        var t = this._array.length;
        this._array.shift(), delete this._array[t], delete this[t]
    }, refresh: function () {
    }, toString: function () {
        return this._array.toString()
    }
};
var ReconstructableMap = function (t) {
    check.isNotUndefined(t), this._map = t;
    for (var e in t)if ((t.hasOwnProperty(e) || t.constructor.hasOwnProperty(e)) && "__rec__" != e.substring(0, 7) && !t.hasOwnProperty("__rec__" + e) && "_reconstructableElements" != e) {
        var n = new Function("return this._map." + e + ";"), r = new Function("value", "if (ContextFactory.hasActiveContext()){                    ContextFactory.getCurrentContext().addReconstructor(new ImplicitReconstructor(this._map, " + e + "));			}			this._map[" + e + "] = value;");
        Object.defineProperty(this, e, {get: n, set: r, configurable: !0, enumerable: !0})
    }
}, funSetCodeMap = function (t, e) {
    ContextFactory.hasActiveContext() && ContextFactory.getCurrentContext().addReconstructor(new ImplicitReconstructor(this._map, e)), this._map[e] = t
};
ReconstructableMap.prototype = {
    constructor: ReconstructableMap, addNewProperty: function (t, e) {
        if (this._map.hasOwnProperty(t))return void(this[t] = e);
        ContextFactory.hasActiveContext() && (ContextFactory.getCurrentContext().addReconstructor(new ExplicitReconstructor(this, "compensateAddNewProperty", [t, e])), ContextFactory.getCurrentContext().reconstructableMethodEntry()), this._map[t] = e;
        var n = new Function("return this._map." + t + ";"), r = new Function("value", "if (ContextFactory.hasActiveContext()){                ContextFactory.getCurrentContext().addReconstructor(new ImplicitReconstructor(this._map, " + t + "));			}			this._map[" + t + "] = value;");
        Object.defineProperty(this, t, {
            get: n,
            set: r,
            configurable: !0,
            enumerable: !0
        }), ContextFactory.hasActiveContext() && ContextFactory.getCurrentContext().reconstructableMethodExit()
    }, compensateAddNewProperty: function (t) {
        delete this._map[t], delete this[t]
    }
};
var ReconstructionUtil = {
    getProperContext: function (t) {
        switch (t.ReconstructionContext) {
            case NEVER:
                if (ContextFactory.hasActiveContext())throw new reconstructorExceptions.InvalidReconstructionException("a current reconstruction context can't exist for NEVER reconstruction option");
                return ContextFactory.createNullContext();
            case NEW:
                return ContextFactory.createContext();
            case SUSPEND:
                return ContextFactory.createNullContext();
            default:
                throw new reconstructorExceptions.InvalidReconstructionException("inconsistent switch case")
        }
    }, isAllowedException: function (t, e, n) {
        return t ? e && 0 !== e.length || n && 0 !== n.length ? e && e.length > 0 ? this.exceptionIn(t, e) ? !0 : !1 : this.exceptionIn(t, n) ? !1 : !0 : !0 : !1
    }, exceptionIn: function (t, e) {
        if (!e || !t)return !1;
        check.isArray(e);
        for (var n = e.length, r = 0; n > r; r++)if (t instanceof extensionsArray[r])return !0;
        return !1
    }, getBestRetry: function (t, e) {
        if (!e.retriesArray)return null;
        var n = null, r = e.retriesArray, o = Number.POSITIVE_INFINITY, s = r.length;
        if (1 === s)return r[0];
        for (var c = 0; s > c; c++) {
            var i = this.getMinKinship(t.constructor, r[c].whenExceptionsArray);
            o > i && (o = i, n = r[c])
        }
        return n
    }, getMinKinship: function (t, e) {
        check.isArray(e);
        for (var n = Number.POSITIVE_INFINITY, r = e.length, o = 0; r > o; o++) {
            var s = this.getKinship(t, e[o]);
            n > s && (n = s)
        }
        return n
    }, getKinship: function (t, e) {
        for (var n = 0; ;) {
            if (!t)return Number.POSITIVE_INFINITY;
            if (t === Object)return Number.POSITIVE_INFINITY;
            if (t === e)break;
            n++, t = t.prototype.constructor
        }
        return n
    }, getUnsafe: function () {
    }, pauseComp: function (t) {
        var e = new Date, n = null;
        do n = new Date; while (t > n - e)
    }, delay: function (t) {
        0 >= t || this.pauseComp(t)
    }, shouldWeRetry: function (t, e, n) {
        return n ? e < n.times + 1 : !1
    }, reconstructionNeeded: function (t, e) {
        return ContextFactory.getCurrentContext().currentNumberOfAsyncErrors < e.minNumberOfAsyncErrorsToReconstruct ? !1 : this.isAllowedException(t, e.whenExceptionsArray, e.unlessExceptionsArray)
    }
}, NEW = 1, NEVER = 2, SUSPEND = 3, Retry = function (t, e, n) {
    check.isNumber(t), check.isNumber(e), this.times = t, this.delay = e, n ? (check.isArray(n), this.whenExceptionsArray = n.length > 0 ? n : [Error]) : this.whenExceptionsArray = [Error]
}, ReconstructionOptions = function (t, e, n, r, o, s) {
    if (this.ReconstructionContext = t ? t : NEW, e) {
        check.isArray(e);
        for (var c = e.length, i = 0; c > i; i++)check.isFunction(e[i]);
        this.whenExceptionsArray = e
    } else this.whenExceptionsArray = [];
    if (n) {
        check.isArray(n);
        for (var c = n.length, i = 0; c > i; i++)check.isFunction(n[i]);
        this.unlessExceptionsArray = n
    } else this.unlessExceptionsArray = [];
    if (r) {
        check.isArray(r);
        for (var c = r.length, i = 0; c > i; i++)check.isRetry(r[i]);
        this.retriesArray = r
    } else this.retriesArray = null;
    this.minNumberOfAsyncErrorsToReconstruct = o ? o : 1, this.finallyFunction = s ? s : null
}, Reconstructor = function () {
    inheritanceUtil.isAbstract(Reconstructor)
};
Reconstructor.prototype = {constructor: Reconstructor};
var ImplicitReconstructor = function (t, e) {
    this._objectReference = t, this._fieldName = e, this._fieldValue = t[e]
};
ImplicitReconstructor.prototype = {
    constructor: ImplicitReconstructor, discard: function () {
    }, reconstruct: function () {
        this._objectReference[this._fieldName] = this._fieldValue
    }
};
var ExplicitReconstructor = function (t, e, n) {
    this._objectReference = t, this._compensationMethodName = e, this._argsArray = n
};
ExplicitReconstructor.prototype = function () {
    var t = function (t, e) {
        if (e) {
            for (var n = e.length, r = 0; n > r; r++)t.push(e[r]);
            return t
        }
        return t
    };
    return {
        constructor: ExplicitReconstructor, discard: function () {
        }, reconstruct: function () {
            this._objectReference[this._compensationMethodName].apply(this._objectReference, t(this._argsArray, this._extraArguments))
        }, addExtraArguments: function (t) {
            this._extraArguments || (this._extraArguments = new Array);
            for (var e = t.length, n = 0; e > n; n++)this._extraArguments.push(t[n])
        }
    }
}();
var currentContext = {
    _currentContext: null, get: function () {
        return this._currentContext
    }, set: function (t) {
        this._currentContext = t
    }
}, ContextFactory = {
    createContext: function () {
        return new DefaultContext
    }, createIndependentContext: function () {
        var t = new DefaultContext;
        return t.setParentContext(null), t
    }, createNullContext: function () {
        return new NullContext
    }, getCurrentContext: function () {
        return currentContext._currentContext
    }, getCurrentContextId: function () {
        return currentContext._currentContext ? currentContext._currentContext._id : "No Current Context"
    }, hasActiveContext: function () {
        return null != currentContext._currentContext
    }
}, BaseContext = function () {
    inheritanceUtil.isAbstract(BaseContext), inheritanceUtil.superConstructor(this, Reconstructor), this._id = (new Date).getMilliseconds(), this._OPEN = 0, this._CLOSED = 1, this._CLOSED_ATTACHED = 2, this._parentContext = null, this._previousContext = null, this._suspended = !1, this._state = this._OPEN, this._previousContext = currentContext.get(), currentContext.set(this)
}, BaseContextPrototype = function () {
    return {
        constructor: BaseContext, getId: function () {
            return this._id
        }, restorePreviousContext: function () {
            currentContext.set(this._previousContext)
        }, isRootContext: function () {
            return null === this._parentContext
        }, isCurrentContext: function () {
            return this === currentContext.get()
        }, isOpen: function () {
            return this._state === this._OPEN
        }, suspend: function () {
            this._suspended = !0
        }, resume: function () {
            this._suspended = !1
        }, invalidate: function () {
            this.suspend(), this._state = this._CLOSED, this.restorePreviousContext(), this.isRootContext() || this._parentContext.removeReconstructor(this)
        }, isSuspended: function () {
            return this._suspended
        }, setParentContext: function (t) {
            null !== this._parentContext && this._parentContext.removeReconstructor(this), this._parentContext = t, null !== this._parentContext && this._parentContext.addReconstructor(this)
        }, getParentContext: function () {
            return this._parentContext
        }, reconstruct: function () {
            if (this.suspend(), this._state === this._CLOSED)throw new reconstructorExceptions.InvalidReconstructionException("Closed context can�t be reconstructed");
            this.doReconstruction(), this.isOpen() && this.restorePreviousContext(), this._state = this._CLOSED, this.isRootContext() || this._parentContext.removeReconstructor(this)
        }, discard: function () {
            this.isOpen() && (this.isRootContext() ? (this.doDiscard(), this._state = this._CLOSED) : this._state = this._CLOSED_ATTACHED, this.restorePreviousContext())
        }
    }
}();
inheritanceUtil.inheritPrototypeAndAugment(BaseContext, Reconstructor, BaseContextPrototype);
var DefaultContext = function () {
    this._id = (new Date).getMilliseconds(), this._OPEN = 0, this._CLOSED = 1, this._CLOSED_ATTACHED = 2, this.currentNumberOfAsyncErrors = 0, this._parentContext = null, this._previousContext = null, this._suspended = !1, this._state = this._OPEN, this._previousContext = currentContext.get(), currentContext.set(this), this._stack = [], this._callStack = [], this._asyncElements = new AsyncElements, this._asyncReconstructionOptions = null, this.setParentContext(this._previousContext)
};
DefaultContext.prototype = function () {
    var t = function (t) {
        if (t.length <= 0)throw new reconstructorExceptions.InvalidReconstructionException("Call stack is empty")
    }, e = function (t) {
        if (t.length <= 0)throw new reconstructorExceptions.InvalidReconstructionException("Reconstructor stack is empty")
    }, n = function (t) {
        if (!(t && t instanceof ExplicitReconstructor))throw new reconstructorExceptions.InvalidReconstructionException("Reconstructor is not an ExplicitReconstructor")
    };
    return {
        constructor: DefaultContext, getId: function () {
            return this._id
        }, addNewAjaxAsyncElement: function (t) {
            this._asyncElements.addNewAjaxAsyncElement(t)
        }, addNewTimeoutAsyncElement: function (t) {
            this._asyncElements.addNewTimeoutAsyncElement(t)
        }, addNewTimeintervalAsyncElement: function (t) {
            this._asyncElements.addNewTimeintervalAsyncElement(t)
        }, addNewMutationObserverAsyncElement: function (t, e, n) {
            this._asyncElements.addNewMutationObserverAsyncElement(t, e, n)
        }, hasAsyncElementId: function (t) {
            this._asyncElements.hasAsyncElementId(t)
        }, deleteAsyncElementById: function (t) {
            this._asyncElements.deleteAsyncElementById(t)
        }, getAsyncElements: function () {
            return this._asyncElements.getAsyncElements()
        }, areThereAsyncElements: function () {
            return this._asyncElements.areThereAsyncElements()
        }, getAsyncReconstructionOptions: function () {
            return this._asyncReconstructionOptions
        }, restorePreviousContext: function () {
            currentContext.set(this._previousContext)
        }, isRootContext: function () {
            return null === this._parentContext
        }, isCurrentContext: function () {
            return this === currentContext.get()
        }, isOpen: function () {
            return this._state === this._OPEN
        }, suspend: function () {
            this._suspended = !0
        }, resume: function () {
            this._suspended = !1
        }, invalidate: function () {
            this.suspend(), this._state = this._CLOSED, this.restorePreviousContext(), this.isRootContext() || this._parentContext.removeReconstructor(this)
        }, isSuspended: function () {
            return this._suspended
        }, setParentContext: function (t) {
            null !== this._parentContext && this._parentContext.removeReconstructor(this), this._parentContext = t, null !== this._parentContext && this._parentContext.addReconstructor(this)
        }, getParentContext: function () {
            return this._parentContext
        }, reconstruct: function () {
            if (this.suspend(), this._state === this._CLOSED)throw new reconstructorExceptions.InvalidReconstructionException("Closed context can�t be reconstructed");
            this.doReconstruction(), this.isOpen() && this.restorePreviousContext(), this._state = this._CLOSED, this.isRootContext() || this._parentContext.removeReconstructor(this)
        }, discard: function () {
            this.isOpen() && (this.isRootContext() ? (this.doDiscard(), this._state = this._CLOSED) : this._state = this._CLOSED_ATTACHED, this.restorePreviousContext())
        }, discardAsync: function (t) {
            if (this.isOpen()) {
                if (!this.areThereAsyncElements())return void this.discard();
                this._asyncReconstructionOptions = t, this.suspend(), this.restorePreviousContext()
            }
        }, doReconstruction: function () {
            for (var t = this._stack.length, e = t - 1; e >= 0; e--)this._stack[e].reconstruct();
            this._stack = [], this._callStack = []
        }, doDiscard: function () {
            this._stack = [], this._callStack = []
        }, addReconstructor: function (t) {
            !this.isSuspended() && this.isOpen() && this._stack.push(t)
        }, removeReconstructor: function (t) {
            for (var e = this._stack.length, n = 0; e > n; n++)if (this._stack[n] === t)return this._stack.splice(n, 1)
        }, getSize: function () {
            return this._stack.length
        }, addExtraArguments: function (e) {
            t(this._callStack);
            var n = this._callStack.length - 1, r = this._callStack[n];
            r.addExtraArguments(e)
        }, reconstructableMethodEntry: function () {
            e(this._stack);
            var t = this._stack.length - 1, r = this._stack[t];
            n(r), this._callStack.push(r)
        }, reconstructableMethodExit: function () {
            t(this._callStack), this._callStack.pop()
        }
    }
}();
var NullContext = function () {
    this._id = (new Date).getMilliseconds(), this._OPEN = 0, this._CLOSED = 1, this._CLOSED_ATTACHED = 2, this._parentContext = null, this._previousContext = null, this._suspended = !1, this._state = this._OPEN, this._previousContext = currentContext.get(), currentContext.set(this), this._size = 0
};
NullContext.prototype = {
    constructor: NullContext, getId: function () {
        return this._id
    }, restorePreviousContext: function () {
        currentContext.set(this._previousContext)
    }, isRootContext: function () {
        return null === this._parentContext
    }, isCurrentContext: function () {
        return this === currentContext.get()
    }, isOpen: function () {
        return this._state === this._OPEN
    }, suspend: function () {
        this._suspended = !0
    }, resume: function () {
        this._suspended = !1
    }, invalidate: function () {
        this.suspend(), this._state = this._CLOSED, this.restorePreviousContext(), this.isRootContext() || this._parentContext.removeReconstructor(this)
    }, isSuspended: function () {
        return this._suspended
    }, setParentContext: function (t) {
        null !== this._parentContext && this._parentContext.removeReconstructor(this), this._parentContext = t, null !== this._parentContext && this._parentContext.addReconstructor(this)
    }, getParentContext: function () {
        return this._parentContext
    }, reconstruct: function () {
        if (this.suspend(), this._state === this._CLOSED)throw new reconstructorExceptions.InvalidReconstructionException("Closed context can�t be reconstructed");
        this.doReconstruction(), this.isOpen() && this.restorePreviousContext(), this._state = this._CLOSED, this.isRootContext() || this._parentContext.removeReconstructor(this)
    }, discard: function () {
        this.isOpen() && (this.isRootContext() ? (this.doDiscard(), this._state = this._CLOSED) : this._state = this._CLOSED_ATTACHED, this.restorePreviousContext())
    }, addReconstructor: function () {
        !this.isSuspended() && this.isCurrentContext() && this._size++
    }, removeReconstructor: function () {
        this._size > 0 && this._size--
    }, getSize: function () {
        return this._size
    }, doDiscard: function () {
        this._size = 0
    }, doReconstruction: function () {
        this._size = 0
    }, addExtraArguments: function () {
    }, reconstructableMethodEntry: function () {
    }, reconstructableMethodExit: function () {
    }
};
var HashTable = function () {
    this._size = 0, this._hashTable = {}
};
HashTable.prototype = {
    constructor: HashTable, put: function (t, e) {
        check.isString(t), check.isNotUndefined(e), this._hashTable[t] = e, this._size++
    }, get: function (t) {
        return this._hashTable[t]
    }, clear: function () {
        for (var t in this._hashTable)this._hashTable.hasOwnProperty(t) && delete this._hashTable[t];
        this._size = 0
    }, remove: function (t) {
        check.isString(t), delete this._hashTable[t], this._size--
    }, size: function () {
        return this._size
    }
};
var ReconstructableElements = function () {
    this._hashTable = new HashTable
};
ReconstructableElements.prototype = function () {
    var t = 0, e = 1, n = 2, r = 3, o = function (o, s) {
        switch (o) {
            case t:
                this.isProperty = !0;
                break;
            case e:
                this.isMethod = !0, this.reconstructorMethodName = s;
                break;
            case n:
                this.isToReconstructor = !0;
                break;
            case r:
                this.reconstructionOptions = s ? s : new ReconstructionOptions, this.isReconstruction = !0;
                break;
            default:
                throw new reconstructorExceptions.InvalidReconstructionException("ReconstructableElement -> Incorrect type at ReconstructableElement Constructor")
        }
    };
    return {
        constructor: ReconstructableElements, addProperty: function (e) {
            var n = this._hashTable.get(e);
            n ? n.isProperty = !0 : this._hashTable.put(e, new o(t))
        }, addMethod: function (t, n) {
            var r = this._hashTable.get(t);
            r ? (r.isMethod = !0, r.reconstructorMethodName = n) : this._hashTable.put(t, new o(e, n))
        }, addToReconstructor: function (t) {
            var e = this._hashTable.get(t);
            e ? e.isToReconstructor = !0 : this._hashTable.put(t, new o(n))
        }, addReconstruction: function (t, e) {
            var n = this._hashTable.get(t);
            n ? (n.isReconstruction = !0, n.reconstructionOptions = e) : this._hashTable.put(t, new o(r, e))
        }, contains: function (t) {
            return this._hashTable.get(t) ? !0 : !1
        }, isReconstructableProperty: function (t) {
            var e = this._hashTable.get(t);
            return e && e.isProperty ? !0 : !1
        }, isReconstructableMethod: function (t) {
            var e = this._hashTable.get(t);
            return e && e.isMethod ? !0 : !1
        }, isToReconstructorMethod: function (t) {
            var e = this._hashTable.get(t);
            return e && e.isToReconstructor ? !0 : !1
        }, isReconstructionMethod: function (t) {
            var e = this._hashTable.get(t);
            return e && e.isReconstruction ? !0 : !1
        }, getReconstructorMethodName: function (t) {
            var e = this._hashTable.get(t);
            return e ? e.reconstructorMethodName : void 0
        }, getReconstructionOptions: function (t) {
            var e = this._hashTable.get(t);
            if (e && e.isReconstruction) {
                var n = e.reconstructionOptions;
                return check.isReconstructionOptions(n), n
            }
        }, clear: function () {
            this._hashTable.clear()
        }
    }
}();
var reconstructable = {
    object: {
        theseProperties: function (t, e) {
            check.isArray(e), t._reconstructableElements || (t._reconstructableElements = new ReconstructableElements);
            for (var n = e.length, r = t._reconstructableElements, o = 0; n > o; o++) {
                var s = e[o];
                check.objectPropertyExists(t, e[o]), r.addProperty(e[o]);
                var c = new Function("return this['__rec__" + s + "'];"), i = new Function("value", "if (ContextFactory.hasActiveContext()){                        ContextFactory.getCurrentContext().addReconstructor(new ImplicitReconstructor(this, '__rec__" + s + "'));					}					this['__rec__" + s + "'] = value;");
                t["__rec__" + s] = t[s], Object.defineProperty(t, s, {get: c, set: i})
            }
        }, allExceptTheseProperties: function (t, e) {
            check.isNotUndefined(t), check.isArray(e), t._reconstructableElements || (t._reconstructableElements = new ReconstructableElements);
            var n = t._reconstructableElements, r = !0, o = e.length;
            for (var s in t)if ("_reconstructableElements" != s) {
                r = !0;
                for (var c = 0; o > c; c++)if (s === e[c]) {
                    r = !1;
                    break
                }
                if (1 == r) {
                    n.addProperty(s);
                    var i = new Function("return this['__rec__" + s + "'];"), a = new Function("value", "if (ContextFactory.hasActiveContext()){                                ContextFactory.getCurrentContext().addReconstructor(new ImplicitReconstructor(this, '__rec__" + s + "'));							}							this['__rec__" + s + "'] = value;");
                    t["__rec__" + s] = t[s], Object.defineProperty(t, s, {get: i, set: a})
                }
            }
        }, allProperties: function (t) {
            check.isNotUndefined(t), t._reconstructableElements || (t._reconstructableElements = new ReconstructableElements);
            var e = t._reconstructableElements;
            for (var n in t)if ((t.hasOwnProperty(n) || t.constructor.hasOwnProperty(n)) && "__rec__" != n.substring(0, 7) && !t.hasOwnProperty("__rec__" + n) && "_reconstructableElements" != n) {
                e.addProperty(n);
                var r = new Function("return this['__rec__" + n + "'];"), o = new Function("value", "if (ContextFactory.hasActiveContext()){                            ContextFactory.getCurrentContext().addReconstructor(new ImplicitReconstructor(this, '__rec__" + n + "'));						}						this['__rec__" + n + "'] = value;");
                t["__rec__" + n] = t[n], Object.defineProperty(t, n, {get: r, set: o})
            }
        }, array: function (t, e) {
            check.isArray(t[e]);
            var n = new ReconstructableArray(t[e]);
            t[e] = n
        }, arrays: function (t, e) {
            check.isArray(e);
            for (var n = e.length, r = 0; n > r; r++)this.array(t, e[r])
        }, domElement: function (t, e) {
            check.isArray(e);
            var n = reconstructableDomElements.getReconstructableElementById(reconstructableDomElements.getElementId(t));
            if ("undefined" == typeof n) {
                var n = {};
                n.prototype = t, t._reconstructableElements || (t._reconstructableElements = new ReconstructableElements), n._reconstructableElements = t._reconstructableElements
            }
            for (var r = e.length, o = t._reconstructableElements, s = 0; r > s; s++) {
                var c = e[s];
                check.objectPropertyExists(t, e[s]), o.addProperty(e[s]);
                var i = new Function("return this.prototype['" + c + "'];"), a = new Function("value", "if (ContextFactory.hasActiveContext()){                        ContextFactory.getCurrentContext().addReconstructor(new ImplicitReconstructor(this.prototype, '" + c + "'));					}					this.prototype['" + c + "'] = value;");
                return n[c] = n.prototype[c], n.id = n.prototype.id, n.classList = n.prototype.classList, Object.defineProperty(n, c, {
                    get: i,
                    set: a
                }), n
            }
        }, domElementsWithIds: function (t, e) {
            t.forEach(function (t) {
                reconstructableDomElements.addIdProperties(t, e)
            })
        }, domElementsWithClass: function (t, e) {
            t.forEach(function (t) {
                reconstructableDomElements.addClassProperties(t, e)
            })
        }, method: function (t, e, n) {
            check.objectPropertyIsMethod(t, e), check.objectPropertyIsMethod(t, n), t._reconstructableElements || (t._reconstructableElements = new ReconstructableElements), t._reconstructableElements.addMethod(e, n);
            var r = new Function("args", "func", "obj", "if (!ContextFactory.hasActiveContext() || !obj._reconstructableElements || !obj._reconstructableElements.isReconstructableMethod('" + e + "') ) {return;}					var argsArray = Array.prototype.slice.call(args);					ContextFactory.getCurrentContext().addReconstructor(new ExplicitReconstructor(obj, '" + n + "', argsArray));					ContextFactory.getCurrentContext().reconstructableMethodEntry();"), o = new Function("result", "args", "func", "obj", "if (!ContextFactory.hasActiveContext() || !obj._reconstructableElements || !obj._reconstructableElements.isReconstructableMethod('" + e + "') ) {return;}					ContextFactory.getCurrentContext().reconstructableMethodExit();");
            Ajaxpect.addBefore(t, e, r), Ajaxpect.addAfter(t, e, o)
        }, toReconstructor: function () {
            if (ContextFactory.hasActiveContext()) {
                var t = Array.prototype.slice.call(arguments);
                ContextFactory.getCurrentContext().addExtraArguments(t)
            }
        }, reconstruction: function (t, e, n) {
            check.objectPropertyIsMethod(t, e), n ? check.isReconstructionOptions(n) : n = new ReconstructionOptions, t._reconstructableElements || (t._reconstructableElements = new ReconstructableElements), t._reconstructableElements.addReconstruction(e, n);
            var r = new Function("args", "func", "obj", "adviceReconstructorMethodCode(args, func, obj, '" + e + "');");
            Ajaxpect.addAround(t, e, r)
        }, reconstructionAsync: function (t, e, n) {
            check.objectPropertyIsMethod(t, e), n ? check.isReconstructionOptions(n) : n = new ReconstructionOptions, t._reconstructableElements || (t._reconstructableElements = new ReconstructableElements), t._reconstructableElements.addReconstruction(e, n);
            var r = new Function("args", "func", "obj", "adviceReconstructorMethodCodeAsync(args, func, obj, '" + e + "');");
            Ajaxpect.addAround(t, e, r)
        }
    }, "class": {
        theseProperties: function (t, e, n) {
            var r = t[e];
            check.isFunction(r), check.isArray(n);
            var o = r.prototype;
            o._reconstructableElements || (o._reconstructableElements = new ReconstructableElements);
            for (var s = o._reconstructableElements, c = n.length, i = 0; c > i; i++) {
                var a = n[i];
                s.addProperty(a);
                var u = new Function("if(typeof this['__rec__" + a + "'] === 'undefined') { 						this['__rec__" + a + "'] = this['" + a + "'];					} 					return this['__rec__" + a + "'];"), h = new Function("value", "if (ContextFactory.hasActiveContext()){                        ContextFactory.getCurrentContext().addReconstructor(new ImplicitReconstructor(this, '__rec__" + a + "'));					}					this['__rec__" + a + "'] = value;");
                Object.defineProperty(o, a, {get: u, set: h})
            }
        }, method: function (t, e, n, r) {
            var o = t[e];
            check.isFunction(o);
            var s = o.prototype;
            s._reconstructableElements || (s._reconstructableElements = new ReconstructableElements), s._reconstructableElements.addMethod(n, r);
            var c = "if (!ContextFactory.hasActiveContext() || !obj._reconstructableElements || !obj._reconstructableElements.isReconstructableMethod('" + n + "') ) {return;}					var argsArray = Array.prototype.slice.call(args);					ContextFactory.getCurrentContext().addReconstructor(new ExplicitReconstructor(obj, '" + r + "', argsArray));					ContextFactory.getCurrentContext().reconstructableMethodEntry();", i = "if (!ContextFactory.hasActiveContext() || !obj._reconstructableElements || !obj._reconstructableElements.isReconstructableMethod('" + n + "') ) {return;}					ContextFactory.getCurrentContext().reconstructableMethodExit();";
            if (s.hasOwnProperty(n)) {
                var a = new Function("args", "func", "obj", c), u = new Function("result", "args", "func", "obj", i);
                Ajaxpect.addBefore(s, n, a), Ajaxpect.addAfter(s, n, u)
            } else {
                var h = new Function("result", "args", "func", "obj", "var adviceBeforeMethod = function (args, func, obj) {                        " + c + "					};					var adviceAfterMethod = function (result, args, func, obj) {						" + i + "					};					Ajaxpect.addBefore(obj, '" + n + "', adviceBeforeMethod);					Ajaxpect.addAfter(obj, '" + n + "', adviceAfterMethod);					return obj;"), l = s;
                Ajaxpect.addAfter(t, e, h), t[e].prototype = l
            }
        }, reconstruction: function (t, e, n, r) {
            var o = t[e];
            check.isFunction(o), r ? check.isReconstructionOptions(r) : r = new ReconstructionOptions;
            var s = o.prototype;
            s._reconstructableElements || (s._reconstructableElements = new ReconstructableElements), s._reconstructableElements.addReconstruction(n, r);
            var c = "if(!obj._reconstructableElements || !obj._reconstructableElements.isReconstructionMethod('" + n + "') ){return;}				var reconstructionOptions = reconstructable.getReconstructionOptions(obj, '" + n + "'),					context = ReconstructionUtil.getProperContext(reconstructionOptions),					hasToRetry = false, tries = 0;				try {					do { 						hasToRetry = false;							tries++; 						try { 							func.apply(obj, args); /*<-- real execution here*/ 						} 						catch (exception) {							if (ReconstructionUtil.reconstructionNeeded(exception, reconstructionOptions)) { 								context.reconstruct();							}							else {								context.invalidate();							}							var retry = ReconstructionUtil.getBestRetry(exception, reconstructionOptions); 							hasToRetry = ReconstructionUtil.shouldWeRetry(exception, tries, retry);							if (hasToRetry){								/*a new context as previous is closed by close() or invalidate()*/								context = ReconstructionUtil.getProperContext(reconstructionOptions); 								ReconstructionUtil.delay(retry.delay);							}							else {								throw exception;							}						}										} while (hasToRetry);				} 				finally {					context.discard();				}";
            if (s.hasOwnProperty(n)) {
                var i = new Function("args", "func", "obj", c);
                Ajaxpect.addAround(t, n, i)
            } else {
                var a = new Function("result", "args", "func", "obj", "var adviceReconstructionMethod = function (args, func, obj) {                        " + c + "					};					Ajaxpect.addAround(obj, '" + n + "', adviceReconstructionMethod);					return obj;"), u = s;
                Ajaxpect.addAfter(t, e, a), t[e].prototype = u
            }
        }
    }, checkIsReconstructableProperty: function (t, e) {
        var n = t._reconstructableElements;
        return n ? n.isReconstructableProperty(e) : !1
    }, checkIsReconstructableMethod: function (t, e) {
        var n = t._reconstructableElements;
        return n ? n.isReconstructableMethod(e) : !1
    }, checkIsToReconstructorMethod: function (t, e) {
        var n = t._reconstructableElements;
        return n ? n.isToReconstructorMethod(e) : !1
    }, checkIsReconstructionMethod: function (t, e) {
        var n = t._reconstructableElements;
        return n ? n.isReconstructionMethod(e) : !1
    }, getReconstructorMethodName: function (t, e) {
        var n = t._reconstructableElements;
        return n ? n.getReconstructorMethodName(e) : void 0
    }, getReconstructionOptions: function (t, e) {
        var n = t._reconstructableElements;
        return n ? n.getReconstructionOptions(e) : void 0
    }
}, adviceReconstructorMethodCode = function (t, e, n, r) {
    if (n._reconstructableElements && n._reconstructableElements.isReconstructionMethod(r)) {
        var o = reconstructable.getReconstructionOptions(n, r), s = ReconstructionUtil.getProperContext(o), c = !1, i = 0;
        try {
            do {
                c = !1, i++;
                try {
                    e.apply(n, t)
                } catch (a) {
                    ReconstructionUtil.reconstructionNeeded(a, o) ? s.reconstruct() : s.invalidate();
                    var u = ReconstructionUtil.getBestRetry(a, o);
                    if (c = ReconstructionUtil.shouldWeRetry(a, i, u), !c)throw a;
                    s = ReconstructionUtil.getProperContext(o), ReconstructionUtil.delay(u.delay)
                }
            } while (c)
        } finally {
            s.discard()
        }
    }
}, adviceReconstructorMethodCodeAsync = function (t, e, n, r) {
    if (n._reconstructableElements && n._reconstructableElements.isReconstructionMethod(r)) {
        var o = reconstructable.getReconstructionOptions(n, r), s = ReconstructionUtil.getProperContext(o), c = !1, i = 0;
        try {
            do {
                c = !1, i++;
                try {
                    e.apply(n, t)
                } catch (a) {
                    if (s.currentNumberOfAsyncErrors++, ReconstructionUtil.reconstructionNeeded(a, o)) {
                        s.reconstruct();
                        var u = 0, h = 1, l = 2, d = 3;
                        s.getAsyncElements().forEach(function (t) {
                            switch (t.type) {
                                case u:
                                    t.value.abort();
                                    break;
                                case h:
                                    clearTimeout(t.value);
                                    break;
                                case l:
                                    clearTimeinterval(t.value);
                                    break;
                                case d:
                                    t.value.disconnect()
                            }
                        })
                    } else s.currentNumberOfAsyncErrors >= o.minNumberOfAsyncErrorsToReconstruct && s.invalidate();
                    var p = ReconstructionUtil.getBestRetry(a, o);
                    if (c = ReconstructionUtil.shouldWeRetry(a, i, p), !c)throw o.finallyFunction && o.finallyFunction(), a;
                    s = ReconstructionUtil.getProperContext(o), ReconstructionUtil.delay(p.delay)
                }
            } while (c)
        } finally {
            s.discardAsync(o)
        }
    }
}, adviceBeforeMethodCode = function (t, e, n, r, o) {
    if (ContextFactory.hasActiveContext() && n._reconstructableElements && n._reconstructableElements.isReconstructableMethod(r)) {
        var s = Array.prototype.slice.call(t);
        ContextFactory.getCurrentContext().addReconstructor(new ExplicitReconstructor(n, o, s)), ContextFactory.getCurrentContext().reconstructableMethodEntry()
    }
}, adviceAfterMethodCode = function (t, e, n, r, o) {
    ContextFactory.hasActiveContext() && r._reconstructableElements && r._reconstructableElements.isReconstructableMethod(o) && ContextFactory.getCurrentContext().reconstructableMethodExit()
}, funGetCode = function (t) {
    return this["__rec__" + t]
}, funSetCode = function (t, e) {
    ContextFactory.hasActiveContext() && ContextFactory.getCurrentContext().addReconstructor(new ImplicitReconstructor(this, "__rec__" + e)), this["__rec__" + e] = t
}, asyncReconstructionExecution = function (t, e, n, r, o) {
    currentContext._currentContext = t, t.resume();
    var s = t.getAsyncReconstructionOptions(), c = !1, i = 0;
    try {
        do {
            c = !1, i++;
            try {
                n.apply(r, o)
            } catch (a) {
                if (t.currentNumberOfAsyncErrors++, ReconstructionUtil.reconstructionNeeded(a, s)) {
                    t.reconstruct();
                    var u = 0, h = 1, l = 2, d = 3;
                    t.getAsyncElements().forEach(function (t) {
                        switch (t.type) {
                            case u:
                                t.value.abort();
                                break;
                            case h:
                                clearTimeout(t.value);
                                break;
                            case l:
                                clearTimeinterval(t.value);
                                break;
                            case d:
                                t.value.takeRecords()
                        }
                    })
                } else t.currentNumberOfAsyncErrors >= s.minNumberOfAsyncErrorsToReconstruct && t.invalidate();
                var p = ReconstructionUtil.getBestRetry(a, s);
                if (c = ReconstructionUtil.shouldWeRetry(a, i, p), !c)throw s.finallyFunction && s.finallyFunction(), a;
                t = ReconstructionUtil.getProperContext(s), ReconstructionUtil.delay(p.delay)
            }
        } while (c)
    } finally {
        t.deleteAsyncElementById(e), t.discardAsync(s)
    }
};
XMLHttpRequest.prototype._send = XMLHttpRequest.prototype.send, XMLHttpRequest.prototype.send = function () {
    if (this.contextAtTimeOfSend = ContextFactory.getCurrentContext(), !this.contextAtTimeOfSend)return void this._send();
    var t = this.contextAtTimeOfSend.addNewAjaxAsyncElement(this), e = this.onload, n = this.onerror, r = this.onreadystatechange;
    null !== e && (this.onload = function () {
        asyncReconstructionExecution(this.contextAtTimeOfSend, t, e, this, arguments)
    }), null !== n && (this.onerror = function () {
        asyncReconstructionExecution(this.contextAtTimeOfSend, t, n, this, arguments)
    }), null !== r && (this.onreadystatechange = function () {
        asyncReconstructionExecution(this.contextAtTimeOfSend, t, r, this, arguments)
    }), XMLHttpRequest.prototype._send.apply(this, arguments)
}, originalSetTimeout = setTimeout, setTimeout = function () {
    var t = ContextFactory.getCurrentContext();
    if (!t)return void originalSetTimeout.apply(this, arguments);
    var e, n = arguments[0];
    arguments[0] = function () {
        asyncReconstructionExecution(t, e, n, this, arguments)
    }, e = t.addNewTimeoutAsyncElement(originalSetTimeout.apply(this, arguments))
}, originalSetInterval = setInterval, setInterval = function () {
    var t = ContextFactory.getCurrentContext();
    if (!t)return void originalSetInterval.apply(this, arguments);
    var e, n = arguments[0];
    arguments[0] = function () {
        asyncReconstructionExecution(t, e, n, this, arguments)
    }, e = t.addNewTimeintervalAsyncElement(originalSetInterval.apply(this, arguments))
};
var originalMutationObserver = MutationObserver, MutationObserver = function (t) {
    var e, n, r = function () {
        return e ? void asyncReconstructionExecution(e, n, t, this, arguments) : void t.apply(this, arguments)
    }, o = new originalMutationObserver(r), s = o.observe;
    return o.observe = function (t, r) {
        var c = {}, i = reconstructableDomElements.getReconstructableElementById(t.id);
        c.prototype = "undefined" == typeof i ? t : i, c.id = c.prototype.id, c.classList = c.prototype.classList, reconstructableDomElements.addElementToIdMap(c), Object.defineProperty(c, "innerHTML", {
            get: function () {
                return this.prototype.innerHTML
            }, set: function (s) {
                return (e = ContextFactory.getCurrentContext()) ? (n = e.addNewMutationObserverAsyncElement(o, t, r), void(this.prototype.innerHTML = s)) : void(this.prototype.innerHTML = s)
            }
        }), c.innerHTML = c.prototype.innerHTML, s.call(this, t, r)
    }, o
};
document.originalGetElementById = document.getElementById, document.getElementById2 = function (t) {
    var e = document.originalGetElementById(t), n = reconstructableDomElements.getIdProperties(t);
    return "undefined" != typeof n && n.length > 0 && (e = reconstructable.object.domElement(e, n)), e
}, document.getElementById = function (t) {
    var e = reconstructableDomElements.getReconstructableElementById(t);
    return "undefined" == typeof e ? document.originalGetElementById(t) : e
}, document.originalGetElementsByClassName = document.getElementsByClassName, document.getElementsByClassName2 = function (t) {
    var e = document.originalGetElementsByClassName(t), n = reconstructableDomElements.getClassProperties(t);
    if ("undefined" != typeof n && n.length > 0) {
        var r = [];
        Array.prototype.forEach.call(e, function (t) {
            r.push(reconstructable.object.domElement(t, n))
        }), e = r
    }
    return e
}, document.getElementsByClassName = function (t) {
    var e = reconstructableDomElements.getReconstructableElementsByClassName(t);
    return "undefined" == typeof e ? document.originalGetElementsByClassName(t) : e
};